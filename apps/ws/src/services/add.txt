A callback is just a function that you pass into another function.
Later, that function gets called automatically when something happens.

function greet(callback: (name: string) => void) {
  const user = "Anand";
  callback(user); // instead of printing, we give "Anand" to whoever calls greet
}
Here callback is a function we will pass in later.

callback(user) means:
ğŸ‘‰ â€œHey, Iâ€™ve got the userâ€™s name. You decide what to do with it.â€

When we call greet, we pass a function:
greet((name) => {
  console.log("Hello " + name);
});
(name) => { console.log("Hello " + name); } is our callback.

Inside greet, it runs callback("Anand").

That becomes: console.log("Hello Anand").
 Output: Hello Anand.




 const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Done!");
  }, 2000);
});

p.then(result => console.log(result)); // prints "Done!" after 2s

new Promise(...) takes a function with two arguments: resolve (success) and reject (failure).
After 2 seconds, we call resolve("Done!")
Whoever was waiting on the promise will now get "Done!".






Bucket part => ğŸ” Step by step with example

Say you have:

tsMs = 16:03:25 (in ms)

minutes = 5

Convert 5 minutes â†’ ms:

5 * 60_000 = 300000 ms


Divide the timestamp by bucket size:

tsMs / 300000 â‰ˆ 53.34


Math.floor(53.34) = 53
(floor pushes it down to the full bucket start)

Multiply back by 300000:

53 * 300000 = 15:55:00


âœ… So any tick at 16:03:25 gets assigned to the 15:55â€“16:00 candle.

ğŸ“Š Why it matters

This is how your system decides which candle a tick belongs to.
Without this â€œbucketing,â€ ticks would just be floating around.

Itâ€™s the foundation of candle building.




now clear everything=> 

Take a timestamp in milliseconds (tsMs) â†’ e.g., 16:03:25.

Take a time interval in minutes (minutes) â†’ e.g., 5.

Calculate:

minutes * 60_000 = bucket size in ms (for 5 min â†’ 300000).

tsMs / bucketSize â†’ figure out how many full buckets have passed.

Math.floor(...) â†’ round down to the nearest full bucket.

Multiply back by bucket size â†’ gives you the bucket start time.

ğŸ‘‰ So basically: â€œSnap this timestamp back to the start of its time block.â€

Why we need it

We need it because candlesticks (OHLCV charts) work in fixed time windows.

Example:

A 5-minute candle means all ticks that happen between 16:00 and 16:04:59 belong to the 16:00 candle.

Without bucketing, ticks at 16:01, 16:02, 16:03 would look like they belong to different times â†’ chaos âŒ.

With bucketing, we group them neatly into one candle (16:00â€“16:04:59) âœ…
In super simple words

This function is like saying:

â€œWhatever time you give me, Iâ€™ll tell you which candle (time box) it belongs to.â€.

We are building time buckets of a fixed size (for example, 1 min, 3 min, 5 min, etc.) so that we can later use them to build candles.

Whenever a new tick (with a timestamp) arrives:

This function checks the tickâ€™s timestamp.

It calculates which bucket (time interval) that tick should belong to.

Example:

If bucket size = 5 minutes

Tick arrives at 16:03:25

Function will say â†’ this tick belongs to the 16:00â€“16:05 bucket.